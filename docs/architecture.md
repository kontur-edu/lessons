# Архитектура проекта
Бэкенд юлёрна написан на C# (.NET Framework 4.7 и .NET Core 2.2). Фронтенд — на JavaScript (Boostrap + jquery и React). В текущий момент проект переезжает с .NET Framework на .NET Core и с Bootstrap + jquery на React.

В качестве хранилища данных в основном используется MS SQL, к которому мы обращаемся через [Entity Framework](https://docs.microsoft.com/ru-ru/dotnet/framework/data/adonet/ef/overview) (и [Entity Framework Core](https://docs.microsoft.com/ru-ru/ef/core/) в новых решениях)

Весь код поделён на проекты. Для бэкенда это csproj-файлы, для нового фронтенда — React-приложение. Весь исходный код лежит в папке `src` репозитория.

## Общие проекты

### Common
Проект, содержащий код, помогающий в разработке. Различные хелперы, не имеющий непосредственного отношения к юлёрну и ничего не знающие про его логику.

### Common.Api
Аналогичный проект, помогающий создавать JSON REST API. Примеры проектов, созданных с помощью него: Web.Api, Antiplagiarism.Api, VideoAnnotations.Api. Содержит логику по автоматической генерации документации для любого нашего АПИ с помощью [сваггера](https://swagger.io).

### Core
Ядро юлёрна. Знает про курсы, модули и слайды. Умеет загружать их из XML-файлов.

Знает про наше логирование, валидацию стиля для решений студентов и другие полезные мелочи. 

### Core.Tests
Тесты на загрузку курсов, модулей и слайдов из XML-файлов.	

## Веб и база данных

### Ulearn.Web
Самый большой проект из существующих. Легаси-бэкенд, обрабатывающий запросы и возращающий полноценные HTML-страницы. Именно от отвечает на запросы, отправленные на https://ulearn.me.

Использует ASP.NET MVC и Razor Pages для генерации страниц. Для запуска использует .NET Framework 4.7 и IIS (или IIS Express на машине разработчиков). Не поддерживает .NET Core.

### Web.Api
Новый бэкенд. REST JSON API для юлёрна. На текущий момент поддерживает только небольшую часть функциональности: пользователей, группы и комментарии. Доступ по адресу https://api.ulearn.me. Документация по АПИ доступна по адресу https://api.ulearn.me/documentation/. Документация автоматически генерируется на основе кода с помощью [сваггера](https://swagger.io). 

Использует .NET Core 2.2, ASP.NET Core и клиентские библиотеки [Востока](https://vostok.tools).

### Database
Проект, знающий о структуре хранения данных в MS SQL. Использует Entity Framework и паттерн репозитория. В основном содержит в себе две вещи: модели, описывающие объекты, хранящиеся в базе данных, и репозитории, выполняющие некоторую высокоуровневую работу над этими данными с помощью запросов Entity Framework («найди пользователя по логину», «обнови все группы этого пользователя»).

### Database.Core
Клон проект Database, портированный на .NET Core и Entity Framework Core. Работа над этим проектом всё ещё ведётся — репозитории мигрируют по мере необходимости их использования в новом Web.Api. На данный момент мигрированы все модели.

**К сожалению, в текущий момент при внесении изменения в Database приходится вносить аналогичные изменения в Database.Core, следя за состоянием миграции и портирования на .NET Core. Как только юлёрн полностью мигрирует на новый Web.Api с Database.Core, проекты Ulearn.Web и Database нужно будет удалить.**

### Frontend

Новое приложение для фронтенда. Использует React, redux и [контуровскую библиотеку контролов](http://tech.skbkontur.ru/react-ui/). 

Создано с помощью [create-react-app](https://github.com/facebook/create-react-app), собирается с помощью node.js и команды `npm build`. На выходе получаются файлы `index.html`, бандл со скриптами и бандл со стилями.

Проект Ulearn.Web автоматически собирает Frontend перед своей сборкой и использует сгенерированные им файлы.

## Антиплагиат

В Юлёрн встроена система антиплагиата студенческих решений. Каждое решение каждой задачи отправляется в отдельный сервис антиплагиата.

С точки зрения архитектуры Антиплагиат — полностью независимый от юлёрна микросервис. Написан на .NET Core, использует клиентские библиотеки Востока, Entity Framework Core и ASP.NET MVC Core. 

Состоит из четырёх проектов:
- `AntiPlagiarism.Web`. Основной проект. Содержит логику антиплагиата, контроллеры для работы REST JSON API и модели для базы данных.
- `AntiPlagiarism.Api`. Маленький проект, содержащий описание моделей для REST API антиплагиата. Нужен, чтобы из основного проекта Ulearn.Web ссылаться на него, а не на большой Antiplagiarism.Web.
- `AntiPlagiarism.Tests`. Тесты на логику антиплагиата.
- `AntiPlagiarism.UpdateDb`. Отдельная консольная утилита, приводящая базу данных антиплагиата в консистентное (с кодом) состояние. Использовалась, когда мы меняли логику выделения *сниппетов* из исходного кода.

## Course.exe

Утилита для авторов курса. Каждый курс — это набор XML-файлов. Утилита позволяет, в частности, посмотреть на то, как будет выглядеть курс, не заливая его на юлёрн. Кроме того, утилита может протестировать курс — например, проверить, что все авторские решения проходят все тесты во всех задачах, а также подготовить курс к экспорту в образовательную платформу EdX.

Исходники утилиты лежат в папке `src/CourseTool`. Для генерации HTML-страниц со слайдами курса используется тот же Razor, что и в Ulearn.Web, однако чтобы не тащить в course.exe зависимость от ASP.NET был использован [Razor Generator](https://marketplace.visualstudio.com/items?itemName=DavidEbbo.RazorGenerator) — плагин для Visual Studio, который по cshtml-файлу генерирует Razor-классы не во время работы приложения, а до компиляции решения. По этой причине вся логика рендера слайда вынесена в специальный файл `SlideHtml.cshtml` (`src/Ulearn.Web/Views/Course/SlideHtml.cshtml`), который с помощью Razor Generator превращается в `SlideHtml.generated.cs`, который и используется в утилите course.exe. **Очень важно редактировать этот файл `SlideHtml.cshtml` только в Visual Studio с установленным плагином Razor Generator.**

## Запуск решений задач по программированию

В текущий момент юлёрн умеет проверять решения к программистским задачам, написанные на C#. Решения, написанные на других языках, могут приниматься к проверке (язык для написания решений определяет автор курса), но автоматически не проверяются. 

Для этого существует отдельный процесс-демон RunCsJob, получающий *задачи с кодом на выполнение* от юлёрна по HTTP, компилирующий код, запускающий его в песочнице с ограничениями, и возвращающий результат работы в юлёрн. 

Для этого есть три проекта:

- `RunCsJob`. Основной процесс-демон.
- `RunCsJob.Api`. Описание моделей для взаимодействия `RunCsJob` и юлёрна по HTTP.
- `CsSandboxer`. Песочница для .NET-процессов. Запускает их в жёстких ограничениях по возможностям: запрещено чтение произвольных файлов, работа с сетью и так далее.

## Интеграция со Степиком
Степик — образовательная платформа http://stepik.org. Один из наших курсов выложен на Степике, при этом код, отправляемый студентами на Степике, проверяет юлёрн. Это делается помощью использования протокола XQueue, придуманного в EdX. Кроме того, мы поддерживаем полу-автоматический экспорт курса на Степик. После публикации новой версии курса на юлёрн можно экспортировать их на степик с помощью их АПИ.

- `Stepik.Api`. Реализация клиента для нужного нам подмножества АПИ Степика. 
- `Stepik.Api.Tests`. И тесты этого клиента
- `XQueue`. Реализация клиента для протокола XQueue. По этому протоколу (работающему поверх HTTP) мы регулярно отправляем запросы на сервер Степика и получаем информаци о новых решениях, отправленных на него студентами по нашим задачам. После проверки отправляем информацию о результате тоже с помощью протокола XQueue. Подробнее об XQueue можно почитать на гитхабе EdX: https://github.com/edx/xqueue.
- `XQueueWatcher`. Демон, который регулярно отправляет запросы на Степик (хотя способен отправлять запросы во все очереди, про которые знает. Очереди настраиваются через основной веб-интерфейс юлёрна). При получении решения на проверку отправляет его в юлёрн, как будто оно пришло от обычного нашего студента. После проверки ответ отправляется на Степик (или в ту очередь, откуда было получено решение) уже самим юлёрном.

## Видео-аннотации

Под некоторыми видео на юлёрне есть аннотации (*транскрибации*) — текстовое описание того, о чём рассказывается в видео. Эти аннотацию создаются пользователями, на текущий момент с помощью механизма гуглдоков. К курсу привязан определённый гуглдок, который мы скачиваем с помощью АПИ гугла, и если он размечен соответствующим образом, то используем текст из него в качестве аннотаций к видео.

Чтобы гугл не забанил нас за большое количество запросов, мы кешируем результаты на час. Для реализации этой логики и написан микросервис Видео-аннотаций. Он состоит из двух проектов:

- `VideoAnnotations.Web`. Простое JSON REST API, использует .NET Core, Common.Api. Ходит в гуглдок, кеширует и парсит его.
- `VideoAnnotations.Api`. Описание моделей для АПИ, на которое ссылается Ulearn.Web, который ходит в сервис видео-аннотаций. 

## Остальные проекты

- `GiftsGranter`. Маленькая консольная утилита, выдающая ачивки контуровским сотрудникам на внутреннем портале Контур.Стафф. Она определяет, кто заслужил ачивки (нужные количества баллов для этого содержатся в конфиге), убеждается, что пользователь в последние два ничего не проходил, и выдаёт ачивку с помощью АПИ Стаффа. Запускается по расписанию каждое буднее утро.
- `Notifications`. Демон, отправляющий уведомления пользователям. Знает про транспорты (лента новостей на сайте, телеграм, почта), умеет перепосылать уведомления, если они почему-то не отправились. Знает о том, что уведомление может протухать (например, кто-то написал комментарий, и через 10 секунд его удалил — уведомление о новом комментарии протухло). Для того, чтобы не спамить протухшими уведомлениями, каждое уведомление отправляется только через минуту после создания.
- `Metrics`. Библиотека для отправки метрик в [графит](https://graphiteapp.org). В том числе используется для отправки keep-alive-метрик: демоны отправляют метрики о том, что они живы, даже если ничего не происходит, раз в 10 секунд. На эту метрику настроен мониторинг: если метрика перестаёт приходить 6 раз в минуту, приходит уведомление.
- `uLearn.Tests`. Модульные тесты на разные части юлёрна. Запускаются на каждый коммит в TeamCity.