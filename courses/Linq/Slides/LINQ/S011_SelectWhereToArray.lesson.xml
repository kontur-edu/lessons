<?xml version='1.0' encoding='UTF-8'?>
<slide xmlns="https://ulearn.me/schema/v2" title="Фильтрация и преобразование" id="{E0114584-4500-40B2-B6D6-DB8AF455978B}">
  <defaultIncludeCodeFile>SelectWhereToArray.cs</defaultIncludeCodeFile>
  <markdown>
		В основе `LINQ` лежит интерфейс __последовательности__ `IEnumerable&lt;T&gt;`. 
		Последовательность — это абстракция чего-то, что можно начать перечислять 
		и переходить от текущего элемента к следующему пока последовательность не закончится (или пока не надоест).

		Массивы, `List`, `Dictionary`, `HashSet` — все эти коллекции реализуют интерфейс последовательности.

		Для `IEnumerable&lt;T&gt;` в пространстве имен `System.Linq` определено множество полезных методов расширения, которые и образуют основу `LINQ`.
		
		Чтобы понимать дальнейший материал, вы должны быть знакомы с концепцией [методов расширения](http://msdn.microsoft.com/ru-ru/library/bb383977.aspx) 
		и синтаксисом [лямбда-выражений](http://msdn.microsoft.com/ru-ru/library/bb397687.aspx).

		## Методы фильтрации и преобразования

		`Where` используется для фильтрации перечисляемого. Он принимает в качестве параметра функцию-предикат
		и возвращает новое перечисляемое, состоящее только из тех элементов исходного перечисляемого, на которых предикат вернул `true`.
		
		Вот его полная сигнатура:

		`IEnumerable&lt;T&gt; Where(this IEnumerable&lt;T&gt; items, Func&lt;T, bool&gt; predicate)`

		`Select` используется для поэлементного преобразования перечисляемого. Он принимает в качестве параметра преобразующую функцию 
		и возвращает новое перечисляемое, полученное применением этой функции к каждому элементу исходного перечисляемого.
		
		`IEnumerable&lt;R&gt; Select(this IEnumerable&lt;T&gt; items, Func&lt;T, R&gt; map)`
		
		Самое время еще раз взглянуть на пример с первого слайда — его логика должна проясниться:
	</markdown>
  <includeCode>
    <display>GetNewLetterIds</display>
  </includeCode>
</slide>
